### problem 1 

2022.10.26. 1800
리스트의 요소를 구하는 메소드로 컬렉션프레임워크로 주어지고 있기 때문에 size()를 사용해서 바로 알 수 있다. 

2022.10.26. 1900
리팩토링 해야 할 부분 : 제한사항으로 리턴 -1을 하도록 하는 if 절 기능을 어떻게 메소드로 뺄지 고민 

2022.10.26. 2200
작동은 되도록 하는 로직 완성
1. 최대값을 구할 때 리스트를 쓰지 않고 구할 수 없을까
2. 자리수를 나누고 각 숫자마다 반복문을 돌려서 덧셈과 곱셉의 최대값을 구하고
3. 그걸 또 리턴해와서 list를 만들어서 최대값을 구하는 것
뭔가 이래서는 안되는걸 알면서도 달리 방법을 모르겠다. 

어떻게 공부를 해야 이 코드를 뜯어고칠수 있을까 . . .


### problem 2 

2022.10.27 1500
문자열을 하나 하나씩 비교하는 반복문을 생각할 수도 있겠지만
어떻게든 regex를 이용해서 풀어보고 싶었다. 

regex 관련 공부를 했다. 

자바에서는 개행문자 때문에 \를 한 번 더 써주어야 하고 
\w는 모든 word를 의미, \1+은 중복되는 것을 찾는다. 
+는 1회 이상 반복되는 값을 나타낸다. 
괄호를 통해 문자 단위를 만든다. 

패턴 Matcher의 find()를 통해 regex에 일치하는 상황이 발생했을 때 true를 리턴 받는다.
matcher에 다양한 함수가 있었지만 한번에 문제를 해결할 수 있는 것으로 
여러가지를 시도했지만 딱 원하는 위치의 원하는 문자를 리턴해주는 메소드를 
찾지 못해서 반복문을 사용해서 돌리면서 
이때 stringbuffer를 이용해 찾은 위치의 문자를 ""으로 대체함으로써 삭제하는 방법을 찾았다.

1회로 돌렸을 때 원하는 값인 browoannaon가 나왔고 
반복문으로 find()에서 false가 리턴될 때까지 찾으면 정답을 구할 수 있게 되었다. 

2022.10.27 2000 
기능별 메소드를 분리하고자 했으나 변수 초기화와 while문 구성에서 다른 방법을 찾지 못해
추후 리팩토링 과제로 남겨두기로 하고 커밋 


### problem 3 

2022.10.27 2100
number가 10 미만일 경우와 그 이상일 경우를 나눠보기... 

2022.10.27 2130
스트링으로 바꾸고 스트링에서 3, 6, 9 값을 찾는 방식으로 했을 경우
중복을 제외하고 쉽게 포착이 가능해진다. 

하지만 중복은. . . 

for문을 돌려서 모든 숫자에 대해서 검증을 하면 너무 많은 자원을 먹게 된다. 

중복만 검증할 것이 아니라 
33, 36, 39 같이 나오는 숫자를 검증해야 한다. 
결국엔 정규식을 이용하는 수 밖에 없는듯 하다. 

33, 36, 39 
63, 66, 69 
93, 96, 99 
133, 166, 169
...
333, 336, 339 
...
3333, 3336, 3339

정규식을 통해 반복 숫자가 나올 때 
카운트를 늘려주는 방식으로 해결 

if문이 너무 nested 된다는 점이 문제 

2022.10.27 2300
치명적인 문제를 발견했다. 
구문이 겹치는 것 외에도 숫자가 3자리수 이상으로 올라갈 때 333 같은 경우 
카운트를 3번해야 하는데 현재 로직에서는 2번 밖에 하지 못한다. 
결국엔...
접근을 바꾸던가 
새로운 카운트 방법을 써야한다. 


2022.10.27 2350
간단한 방법을 찾았다 => 스트링에서 발견되는 개수를 카운팅으로 바로 포함시켜서 
1개 발견시 +1 2개 발견시 +2 식으로 sum을 구해주면 된다. 


### problem 4 


2022.10.28 0010
자바에서는 아스키 코드를 형변환과 함께 사용할시 유니코드에 해당하는
알파벳을 출력할 수 있는 기능이 있는 것을 확인 
ex) 
System.out.println((char) 65); => A
System.out.println((char) 90); => Z

이말인즉슨, 65~ 90까지의 숫자를 잘 조작하면
정배열과 역배열의 규칙을 발견할 수 있다는 뜻 

규칙을 구하고 + 대소문자 구별로 맞춰준다면
문제를 쉽게 풀 수 있을듯 하다. 

65 = 90 => 155 
... 
73 = 82 => 155

대문자의 경우 155 - a를 해주었을 때 
reverse를 구할 수 있다. 


소문자의 경우 97 ~ 122 
=> 219

대소문자 구분과 스페이스 처리하는 부분을 
업데이트 

반복문을 통해 쉽게 출력 성공!

2022.10.28 0040
그런데... 
이번 문제는 생각보다 쉽게 풀려서 그런지
찜찜함이 가시질 않긴한다. 



### problem 5

2022.10.28 0830
5만원 권 ~ 1원까지 단순 반복문을 돌려서 
하나씩 추출하는 방법을 쓰면 너무 많은 중첩문들이 생길 것이 뻔하다. 

원 단위를 배열로 만들고 그것을 꺼내면서 
반복문을 돌리며 카운트를 계산하는 방식을 사용 

이때 카운트를 구하는 것은 구현이 가능한데 문제는 
리스트에 집어넣는 때였다. 

문제의 처음에 제시된 리스트 형식이 Collections.emptylist() 이기 때문에
이것을 그대로 사용하는 방법을 고민했다. 

검색 결과 Collections.emptylist() 방식과 new ArrayList() 방식의 차이를 다루는 글들이 보였다. 

핵심 차이는 불변성에 있다고 한다. 
emptylist() 방식은 수정되지 않는 배열을 리턴한다. 
따라서 add 하는 방식으로 사용이 불가능하다는 점이다. 

이 방식은 list 타입을 반환하지 않고 list<T>를 반환하기 때문에 타입 안전성을 보장한다는 
장점이 있어서 사용된다고 한다. 

이것이
계속해서 UnsupportedOperationException이 발생한 이유이고
지금의 내가 쓰는 코드는 따라서 이 방식이 완전히 문제가 되는 
상황이다. 

그렇다면...
고민이 드는 것이다. 

대체 왜 이런 방식이 기본 셋업으로 주어졌을까? 

2022.10.28 0940

스택오버플로우를 비롯해 여러 커뮤니티의 글들을 
읽고 내린 결론은 
결국 emptylist()는 절대적으로 빈 리스트만을 리턴해야 할 때만 
사용할 수 있다는 것이며 
그렇다면 대체 왜 이걸 사용하는가를 고민하면서
얻은 답변은 
이것의 사용 이유는 empty 리스트를 반환해야 하는 상황에서
cpu 등의 자원 효율성을 위해서 사용한다는 것이었다. 

따라서 결론적으로 이번 문제에서는 이 방식을 유지하면서는
절대 원하는 값을 리턴할 수 없다는 결론이 나왔다. 


### problem 6

2022.10.28 1300

2차원 배열 
이 문제를 보고 처음 떠올린 생각은 카테시안 곱이었다. 

2022.10.28 1430
숫자 값이 아니기 때문에 카테시안 곱을 이용하기는 애매하다는 결론. 

반복문 내에서 
forms.get(i)으로 1차원 배열에 접근할 수 있다.
그렇다면 각각의 배열을 하나씩 비교하는 방식의 풀이를 고려해본다. 

0 -> 비교 1,2,3,4,5 
1 -> 비교 0,2,3,4,5  

이때 1차원 배열에 해당하는 리스트를 제외한 나머지 2차원 리스트를 반복문을 돌리는 방식을
사용해보려 했으나 remove()가 되지 않기 때문에 다른 방식을 고려 


2022.10.28 1500 
2차원 배열에서 요소인 1차원 리스트에 접근하여
개별적으로 비교하는 로직을 구성하는 것까지 성공 

이제 각각의 리스트에서 name을 뽑아낼 수 있기 때문에
name간 비교가 가능해졌다.

여기서 name을 어떤 방식으로 비교할지를 고민 
문제는...
한글자만 같아서는 안되며 같은 글자가 연속적으로 포함되는 경우의
중복을 포착해야 한다는 것이다. 


2022.10.28 1600
중복을 포착하여 불리언을 리턴하는 함수 구성 

이제 중복이 포함된 이름을 포착할 수 있게 되었고
email과 매칭시켜 리스트에 넣어 리턴하는 것으로 답을 
찾을 수 있게 되었다. 

